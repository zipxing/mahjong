{"version":3,"sources":["file:///Users/xinzhou/work/mahjong/star/assets/scripts/EliminationManager.ts"],"names":["EliminationManager","init","console","log","findConnectedBlocks","boardData","startRow","startCol","boardSize","length","isValidPosition","type","targetType","visited","connectedBlocks","i","Array","fill","queue","row","col","push","directions","dr","dc","step","current","shift","dir","dirName","newRow","newCol","neighborType","forEach","block","index","hasValidMoves","findConnectedBlocksWithVisited","globalVisited","highlightConnectedBlocks","highlightCallback","clearHighlight","blocks","getConnectedRegionsStats","totalRegions","validRegions","largestRegionSize","blockTypeDistribution","blockType","Math","max","debugPrintConnectedRegions","stats"],"mappings":"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","sourcesContent":["/**\n * 消除管理器\n * 负责处理方块的连通区域检测和消除逻辑\n */\n\nimport { BlockData } from './BoardManager';\n\nexport class EliminationManager {\n    \n    /**\n     * 初始化消除管理器\n     */\n    init() {\n        console.log('✅ 消除管理器初始化完成');\n    }\n    \n    /**\n     * 查找从指定位置开始的连通同色方块\n     * 使用广度优先搜索(BFS)算法\n     */\n    findConnectedBlocks(boardData: BlockData[][], startRow: number, startCol: number): {row: number, col: number}[] {\n        console.log(`\\n🔍 ===== BFS连通搜索开始 =====`);\n        console.log(`🎯 起始位置: (${startRow}, ${startCol})`);\n        \n        const boardSize = boardData.length;\n        console.log(`📏 棋盘大小: ${boardSize}x${boardSize}`);\n        \n        // 检查起始位置\n        if (!this.isValidPosition(startRow, startCol, boardSize)) {\n            console.log(`❌ 起始位置无效，超出棋盘范围`);\n            return [];\n        }\n        \n        if (boardData[startRow][startCol].type === -1) {\n            console.log(`❌ 起始位置是空位，类型为 -1`);\n            return [];\n        }\n        \n        const targetType = boardData[startRow][startCol].type;\n        console.log(`🎨 目标方块类型: ${targetType}`);\n        \n        const visited: boolean[][] = [];\n        const connectedBlocks: {row: number, col: number}[] = [];\n        \n        // 初始化访问标记\n        for (let i = 0; i < boardSize; i++) {\n            visited[i] = new Array(boardSize).fill(false);\n        }\n        console.log(`✅ 访问标记数组初始化完成`);\n        \n        // BFS队列\n        const queue: {row: number, col: number}[] = [{row: startRow, col: startCol}];\n        visited[startRow][startCol] = true;\n        connectedBlocks.push({row: startRow, col: startCol});\n        console.log(`🚀 BFS队列初始化，起始方块已加入`);\n        \n        // 四个方向：上、下、左、右\n        const directions = [\n            {dr: -1, dc: 0},  // 上\n            {dr: 1, dc: 0},   // 下\n            {dr: 0, dc: -1},  // 左\n            {dr: 0, dc: 1}    // 右\n        ];\n        \n        let step = 0;\n        while (queue.length > 0) {\n            step++;\n            const current = queue.shift()!;\n            console.log(`🔄 步骤 ${step}: 处理方块 (${current.row}, ${current.col}), 队列剩余: ${queue.length}`);\n            \n            // 检查四个方向的邻接方块\n            for (let i = 0; i < directions.length; i++) {\n                const dir = directions[i];\n                const dirName = ['上', '下', '左', '右'][i];\n                const newRow = current.row + dir.dr;\n                const newCol = current.col + dir.dc;\n                \n                console.log(`  👀 检查${dirName}方向: (${newRow}, ${newCol})`);\n                \n                // 检查位置有效性\n                if (!this.isValidPosition(newRow, newCol, boardSize)) {\n                    console.log(`    ❌ 位置无效，超出边界`);\n                    continue;\n                }\n                \n                // 检查是否已访问\n                if (visited[newRow][newCol]) {\n                    console.log(`    ❌ 已访问过`);\n                    continue;\n                }\n                \n                const neighborType = boardData[newRow][newCol].type;\n                console.log(`    🎨 邻居方块类型: ${neighborType} (目标: ${targetType})`);\n                \n                // 检查是否为相同类型的方块\n                if (neighborType === targetType) {\n                    visited[newRow][newCol] = true;\n                    queue.push({row: newRow, col: newCol});\n                    connectedBlocks.push({row: newRow, col: newCol});\n                    console.log(`    ✅ 匹配！加入连通区域，当前总数: ${connectedBlocks.length}`);\n                } else {\n                    console.log(`    ❌ 类型不匹配`);\n                }\n            }\n        }\n        \n        console.log(`🔍 BFS搜索完成！找到 ${connectedBlocks.length} 个连通的类型 ${targetType} 方块:`);\n        connectedBlocks.forEach((block, index) => {\n            console.log(`  ${index + 1}. (${block.row}, ${block.col})`);\n        });\n        console.log(`🔍 ===== BFS连通搜索结束 =====\\n`);\n        \n        return connectedBlocks;\n    }\n    \n    /**\n     * 检查位置是否有效\n     */\n    private isValidPosition(row: number, col: number, boardSize: number): boolean {\n        return row >= 0 && row < boardSize && col >= 0 && col < boardSize;\n    }\n    \n    /**\n     * 检查是否还有可消除的连通区域（2个或以上相连的同色方块）\n     */\n    hasValidMoves(boardData: BlockData[][]): boolean {\n        const boardSize = boardData.length;\n        const visited: boolean[][] = [];\n        \n        // 初始化访问标记\n        for (let i = 0; i < boardSize; i++) {\n            visited[i] = new Array(boardSize).fill(false);\n        }\n        \n        // 遍历整个棋盘\n        for (let row = 0; row < boardSize; row++) {\n            for (let col = 0; col < boardSize; col++) {\n                // 跳过空位和已访问的位置\n                if (boardData[row][col].type === -1 || visited[row][col]) {\n                    continue;\n                }\n                \n                // 查找连通区域\n                const connectedBlocks = this.findConnectedBlocksWithVisited(\n                    boardData, row, col, visited\n                );\n                \n                // 如果找到2个或以上的连通方块，说明还有有效移动\n                if (connectedBlocks.length >= 2) {\n                    console.log(`✅ 找到有效移动: ${connectedBlocks.length} 个连通方块`);\n                    return true;\n                }\n            }\n        }\n        \n        console.log('❌ 没有找到有效移动');\n        return false;\n    }\n    \n    /**\n     * 查找连通方块（带访问标记的版本，用于hasValidMoves）\n     */\n    private findConnectedBlocksWithVisited(\n        boardData: BlockData[][], \n        startRow: number, \n        startCol: number,\n        globalVisited: boolean[][]\n    ): {row: number, col: number}[] {\n        const boardSize = boardData.length;\n        \n        if (!this.isValidPosition(startRow, startCol, boardSize) || \n            boardData[startRow][startCol].type === -1 ||\n            globalVisited[startRow][startCol]) {\n            return [];\n        }\n        \n        const targetType = boardData[startRow][startCol].type;\n        const connectedBlocks: {row: number, col: number}[] = [];\n        const queue: {row: number, col: number}[] = [{row: startRow, col: startCol}];\n        \n        globalVisited[startRow][startCol] = true;\n        connectedBlocks.push({row: startRow, col: startCol});\n        \n        const directions = [\n            {dr: -1, dc: 0},  // 上\n            {dr: 1, dc: 0},   // 下\n            {dr: 0, dc: -1},  // 左\n            {dr: 0, dc: 1}    // 右\n        ];\n        \n        while (queue.length > 0) {\n            const current = queue.shift()!;\n            \n            for (const dir of directions) {\n                const newRow = current.row + dir.dr;\n                const newCol = current.col + dir.dc;\n                \n                if (!this.isValidPosition(newRow, newCol, boardSize) ||\n                    globalVisited[newRow][newCol] ||\n                    boardData[newRow][newCol].type !== targetType) {\n                    continue;\n                }\n                \n                globalVisited[newRow][newCol] = true;\n                queue.push({row: newRow, col: newCol});\n                connectedBlocks.push({row: newRow, col: newCol});\n            }\n        }\n        \n        return connectedBlocks;\n    }\n    \n    /**\n     * 高亮显示连通区域（用于预览）\n     */\n    highlightConnectedBlocks(\n        boardData: BlockData[][], \n        startRow: number, \n        startCol: number,\n        highlightCallback: (row: number, col: number, highlight: boolean) => void\n    ): {row: number, col: number}[] {\n        const connectedBlocks = this.findConnectedBlocks(boardData, startRow, startCol);\n        \n        // 只有2个或以上的方块才进行高亮\n        if (connectedBlocks.length >= 2) {\n            connectedBlocks.forEach(({row, col}) => {\n                highlightCallback(row, col, true);\n            });\n        }\n        \n        return connectedBlocks;\n    }\n    \n    /**\n     * 清除高亮显示\n     */\n    clearHighlight(\n        blocks: {row: number, col: number}[],\n        highlightCallback: (row: number, col: number, highlight: boolean) => void\n    ) {\n        blocks.forEach(({row, col}) => {\n            highlightCallback(row, col, false);\n        });\n    }\n    \n    /**\n     * 获取棋盘上所有连通区域的统计信息\n     */\n    getConnectedRegionsStats(boardData: BlockData[][]): {\n        totalRegions: number,\n        validRegions: number,\n        largestRegionSize: number,\n        blockTypeDistribution: {[type: number]: number}\n    } {\n        const boardSize = boardData.length;\n        const visited: boolean[][] = [];\n        \n        // 初始化访问标记\n        for (let i = 0; i < boardSize; i++) {\n            visited[i] = new Array(boardSize).fill(false);\n        }\n        \n        let totalRegions = 0;\n        let validRegions = 0;\n        let largestRegionSize = 0;\n        const blockTypeDistribution: {[type: number]: number} = {};\n        \n        // 遍历整个棋盘\n        for (let row = 0; row < boardSize; row++) {\n            for (let col = 0; col < boardSize; col++) {\n                // 跳过空位和已访问的位置\n                if (boardData[row][col].type === -1 || visited[row][col]) {\n                    continue;\n                }\n                \n                const blockType = boardData[row][col].type;\n                \n                // 查找连通区域\n                const connectedBlocks = this.findConnectedBlocksWithVisited(\n                    boardData, row, col, visited\n                );\n                \n                if (connectedBlocks.length > 0) {\n                    totalRegions++;\n                    \n                    if (connectedBlocks.length >= 2) {\n                        validRegions++;\n                    }\n                    \n                    largestRegionSize = Math.max(largestRegionSize, connectedBlocks.length);\n                    \n                    // 统计方块类型分布\n                    if (!blockTypeDistribution[blockType]) {\n                        blockTypeDistribution[blockType] = 0;\n                    }\n                    blockTypeDistribution[blockType] += connectedBlocks.length;\n                }\n            }\n        }\n        \n        return {\n            totalRegions,\n            validRegions,\n            largestRegionSize,\n            blockTypeDistribution\n        };\n    }\n    \n    /**\n     * 调试：打印连通区域信息\n     */\n    debugPrintConnectedRegions(boardData: BlockData[][]) {\n        const stats = this.getConnectedRegionsStats(boardData);\n        \n        console.log('📊 连通区域统计:');\n        console.log(`  总区域数: ${stats.totalRegions}`);\n        console.log(`  可消除区域数: ${stats.validRegions}`);\n        console.log(`  最大区域大小: ${stats.largestRegionSize}`);\n        console.log(`  方块类型分布:`, stats.blockTypeDistribution);\n    }\n}\n"]}